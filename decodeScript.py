import struct
import json

# Constants
MAX_PROC_NAME_LEN = 10  # Length for process and step name

# Input file generated by the original script
INPUT_FILE_CFG = 'FilMachine.cfg'
# Output JSON file
OUTPUT_FILE_JSON = 'FilMachineDecode.json'

def read_settings(file):
    settings = {}
    settings["tempUnit"] = struct.unpack('<L', file.read(4))[0]
    settings["waterInlet"] = struct.unpack('<L', file.read(4))[0]
    settings["calibratedTemp"] = struct.unpack('<L', file.read(4))[0]
    settings["filmRotationSpeedSetpoint"] = struct.unpack('<B', file.read(1))[0]
    settings["rotationIntervalSetpoint"] = struct.unpack('<B', file.read(1))[0]
    settings["randomSetpoint"] = struct.unpack('<B', file.read(1))[0]
    settings["isPersistentAlarm"] = struct.unpack('<L', file.read(4))[0]
    settings["isProcessAutostart"] = struct.unpack('<L', file.read(4))[0]
    settings["drainFillOverlapSetpoint"] = struct.unpack('<B', file.read(1))[0]
    return settings

def read_process(file):
    process = {}
    try:
        process["processNameString"] = file.read(MAX_PROC_NAME_LEN + 1).rstrip(b'\x00').decode('UTF-8')
        
        temp_data = file.read(4)
        if len(temp_data) != 4:
            raise struct.error(f"Unexpected data length ({len(temp_data)}) for 'temp'. Expected 4 bytes.")
        process["temp"] = struct.unpack('<L', temp_data)[0]
        
        process["tempTolerance"] = struct.unpack('<B', file.read(1))[0] / 10.0  # Convert to 0.1 precision
        process["isTempControlled"] = struct.unpack('<B', file.read(1))[0]
        process["isPreferred"] = struct.unpack('<B', file.read(1))[0]
        process["filmType"] = struct.unpack('<L', file.read(4))[0]
        process["timeMins"] = struct.unpack('<L', file.read(4))[0]
        process["timeSecs"] = struct.unpack('<B', file.read(1))[0]
        
        num_steps = struct.unpack('<H', file.read(2))[0]
        process["steps"] = []
        for _ in range(num_steps):
            process["steps"].append(read_step(file))
    except struct.error as e:
        print(f"Error reading process: {e}")
    return process

def read_step(file):
    step = {}
    try:
        step["stepNameString"] = file.read(MAX_PROC_NAME_LEN + 1).rstrip(b'\x00').decode('UTF-8')
        step["timeMins"] = struct.unpack('<B', file.read(1))[0]
        step["timeSecs"] = struct.unpack('<B', file.read(1))[0]
        step["type"] = struct.unpack('<L', file.read(4))[0]
        step["source"] = struct.unpack('<L', file.read(4))[0]
        step["discardAfterProc"] = struct.unpack('<B', file.read(1))[0]
    except struct.error as e:
        print(f"Error reading step: {e}")
    return step

def main():
    processes = []

    try:
        with open(INPUT_FILE_CFG, 'rb') as bin_file:
            settings = read_settings(bin_file)
            num_processes = struct.unpack('<l', bin_file.read(4))[0]
            for _ in range(num_processes):
                processes.append(read_process(bin_file))
        
        # Prepare data to write to JSON
        data = {
            "settingsParams": settings,
            "processes": processes
        }

        # Write to JSON file
        with open(OUTPUT_FILE_JSON, 'w') as json_file:
            json.dump(data, json_file, indent=4)

        print(f"Successfully decoded '{INPUT_FILE_CFG}' and wrote JSON data to '{OUTPUT_FILE_JSON}'.")
    
    except IOError as e:
        print(f"Error opening or reading file: {e}")
    except struct.error as e:
        print(f"Struct error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")

if __name__ == "__main__":
    main()
